{-# OPTIONS --without-K --exact-split --safe #-}

module SS2022.Prelude where

open import Agda.Primitive using (Level; lsuc) renaming (Set to Type; lzero to lnil; _⊔_ to lmax) public

private variable i j k : Level

{- Path Types -}

-- For each type, its family of homogeneous path types is generated by constant loops at each point (reflexivity).

data _≡_ {A : Type i} : A → A → Type i where
  ref : (x : A) → x ≡ x
infix 0 _≡_

{-# BUILTIN EQUALITY _≡_  #-}

! : {A : Type i} {x y : A} → x ≡ y → y ≡ x
! (ref _) = ref _

_∙_ : {A : Type i} {x y z : A} → x ≡ y → y ≡ z → x ≡ z
ref _ ∙ ref _ = ref _
infixr 7 _∙_

-- We can hence create a dependent path type as follows:

data Id {B : Type i} (F : B → Type j) : {b₀ b₁ : B} (p : b₀ ≡ b₁) (e₀ : F b₀) (e₁ : F b₁) → Type (lmax i j) where
  rfd : {b : B} (e : F b) → Id F (ref b) e e
  
{- Pi Types -}

-- Pi types are built into Agda, but the following provides a convenient way to specify the Pi type of a fibration.

Π : {B : Type i} (F : B → Type j) → Type (lmax i j)
Π F = ∀ b → F b

-- Identity function.

id : {A : Type i} → A → A
id a = a

-- Composition

_▹_ : {A : Type i} {B : Type j} {F : B → Type k} → (f : A → B) → (Π F) → (a : A) → F (f a)
(f ▹ g) a = g (f a)
infixr 7 _▹_

-- We can transport points between fibers given a path between their base points.

tr : {B : Type i} (F : B → Type j) → {b b' : B} → b ≡ b' → F b → F b'
tr F (ref b) e = e

-- It is convenient to work with pathwise equality of functions:

_∼_ : {B : Type i} {F : B → Type j} (f g : Π F) → Type (lmax i j)
_∼_ {_} {_} {B} {F} f g = {x y : B} → (p : x ≡ y) → tr F p (f x) ≡ g y
infix 0 _∼_

_∼'_ : {A : Type i} {B : Type j} (f g : A → B) → Type (lmax i j)
_∼'_ f g = ∀ {x y} → x ≡ y → f x ≡ g y
infix 0 _∼'_

-- We can apply functions to paths by applying them to their endpoints.

ap : {A : Type i} {B : Type j} (f : A → B) → f ∼' f
ap f (ref a) = ref (f a)

apd : {A : Type i} {B : Type j} (f : A → B) → f ∼ f
apd f (ref a) = ref (f a)

-- We can apply an n-ary function to n paths to get a single path.

ap₂ : {A : Type i} {B : Type j} {C : Type k} (f : A → B → C) {a a' : A} {b b' : B} → a ≡ a' → b ≡ b' → f a b ≡ f a' b'
ap₂ f (ref a) (ref b) = ref (f a b)

-- Note: ap₀ would be ref and ap₁ would be ap.

{- Sigma Types -}

-- An indexed sum consists of a base B and a fibration E.
-- We use a record only to get the eta-reduction rule.
record Σ {B : Type i} (F : B → Type j) : Type (lmax i j) where
  constructor
    _,_
  field
    -- From any pair, we can project out a base point and a fiber point.
    πb : B
    πf : F πb
open Σ public
infixr 0 _,_

-- {-# BUILTIN SIGMA Σ #-}

{- Simple Types -}

data 𝟘 : Type where

𝟘-elim : {F : 𝟘 → Type i} (x : 𝟘) → F x
𝟘-elim ()

𝟘-elim' : {B : Type i} → 𝟘 → B
𝟘-elim' ()

data 𝟙 : Type where
  ⋆ : 𝟙

data 𝟚 : Type where
  𝟎 𝟏 : 𝟚

{-# BUILTIN BOOL  𝟚 #-}
{-# BUILTIN TRUE  𝟏 #-}
{-# BUILTIN FALSE 𝟎 #-}

-- We have a notion of negation:

¬ : Type i → Type i
¬ A = A → 𝟘

data ℕ : Type where
  nil : ℕ
  suc : ℕ → ℕ

{-# BUILTIN NATURAL ℕ #-}

data _+_ (A : Type i) (B : Type j) : Type (lmax i j) where
  il : A → (A + B)
  ir : B → (A + B)

_×_ : Type i → Type j → Type (lmax i j)
L × R = Σ \(_ : L) → R

_↔_ : Type i → Type j → Type (lmax i j)
L ↔ R = (L → R) × (R → L)
