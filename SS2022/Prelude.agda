{-# OPTIONS --without-K --exact-split --safe #-}

module SS2022.Prelude where

open import Agda.Primitive using (Level; lsuc) renaming (Set to Type; lzero to lnil; _⊔_ to lmax) public

private variable i j k ℓ : Level

{- Path Types -}

-- For each type, its family of homogeneous path types is generated by constant loops at each point (reflexivity).

data _≡_ {A : Type i} : A → A → Type i where
  ref : (x : A) → x ≡ x
infix 0 _≡_

{-# BUILTIN EQUALITY _≡_  #-}

! : {A : Type i} {x y : A} → x ≡ y → y ≡ x
! (ref _) = ref _

_∙_ : {A : Type i} {x y z : A} → x ≡ y → y ≡ z → x ≡ z
ref _ ∙ ref _ = ref _
infixr 7 _∙_

-- We can hence create a dependent path type as follows:

data Id {B : Type i} (F : B → Type j) : {b₀ b₁ : B} (p : b₀ ≡ b₁) (e₀ : F b₀) (e₁ : F b₁) → Type (lmax i j) where
  rfd : {b : B} (e : F b) → Id F (ref b) e e
  
{- Pi Types -}

-- Pi types are built into Agda, but the following provides a convenient way to specify the Pi type of a fibration.

Π : {B : Type i} (F : B → Type j) → Type (lmax i j)
Π F = ∀ b → F b

-- Identity function.

id : {T : Type i} → T → T
id a = a

-- Composition

_▹_ : {A : Type i} {B : Type j} {F : B → Type k} → (f : A → B) → (Π F) → (a : A) → F (f a)
(f ▹ g) a = g (f a)
infixr 7 _▹_

-- We can transport points between fibers given a path between their base points.

tr : {B : Type i} (F : B → Type j) → {b b' : B} → b ≡ b' → F b → F b'
tr F (ref b) e = e

-- Pointwise and pathwise equalities of functions:

_∼_ : {B : Type i} {F : B → Type j} (f g : Π F) → Type (lmax i j)
_∼_ f g = ∀ x → f x ≡ g x
infix 0 _∼_

_≡ₚ_ : {B : Type i} {F : B → Type j} (f g : Π F) → Type (lmax i j)
_≡ₚ_ {F = F} f g = ∀ {x y} → (p : x ≡ y) → tr F p (f x) ≡ g y
infix 0 _≡ₚ_

_≡ₘ_ : {D : Type i} {C : Type j} (f g : D → C) → Type (lmax i j)
_≡ₘ_ f g = ∀ {x y} → x ≡ y → f x ≡ g y
infix 0 _≡ₘ_

-- We can apply functions to paths by applying them to their endpoints.

ap : {A : Type i} {B : Type j} (f : A → B) → f ≡ₘ f
ap f (ref a) = ref (f a)

apd : {A : Type i} {B : Type j} (f : A → B) → f ≡ₚ f
apd f (ref a) = ref (f a)

-- We can apply an n-ary function to n paths to get a single path.

ap₂ : {A : Type i} {B : Type j} {C : Type k} (f : A → B → C) {a a' : A} {b b' : B} → a ≡ a' → b ≡ b' → f a b ≡ f a' b'
ap₂ f (ref a) (ref b) = ref (f a b)

-- Note: ap₀ would be ref and ap₁ would be ap.

_∼▹_ : {A : Type i} {B : Type j} {C : Type k} {f g : A → B} → f ∼ g → (h : B → C) → (f ▹ h) ∼ (g ▹ h)
(p ∼▹ h) x = ap h (p x)
infix 7 _∼▹_

_▹∼_ : {A : Type i} {B : Type j} {C : Type k} {f g : B → C} (h : A → B) →  f ∼ g → (h ▹ f) ∼ (h ▹ g)
(h ▹∼ p) x = p (h x)
infix 7 _▹∼_

_▹∼_∼▹_ : {A : Type i} {B : Type j} {C : Type k} {D : Type ℓ} {f g : B → C} (h : A → B) → f ∼ g → (h' : C → D) → (h ▹ f ▹ h') ∼ (h ▹ g ▹ h')
h ▹∼ p ∼▹ h' = h ▹∼ (p ∼▹ h')
infix 7 _▹∼_∼▹_

!∼ : {B : Type i} {F : B → Type j} {f g : Π F} → f ∼ g → g ∼ f
!∼ p x = ! (p x)

_∙∼_ : {B : Type i} {F : B → Type j} {f g h : Π F} → f ∼ g → g ∼ h → f ∼ h
(p ∙∼ q) x = p x ∙ q x
infixr 7 _∙∼_


{- Sigma Types -}

-- An indexed sum consists of a base B and a fibration E.
-- We use a record only to get the eta-reduction rule.
record Σ {B : Type i} (F : B → Type j) : Type (lmax i j) where
  constructor
    _,_
  field
    -- From any pair, we can project out a base point and a fiber point.
    πb : B
    πf : F πb
open Σ public
infixr 0 _,_

-- {-# BUILTIN SIGMA Σ #-}

-- Observational equality of sigma types:

_≡ₛ_ : {B : Type i} {F : B → Type j} (u v : Σ F) → Type (lmax i j)
_≡ₛ_ {F = F} (b , e) (b' , e') = Σ \(p : b ≡ b') → tr F p e ≡ e'
infix 0 _≡ₛ_

≡ₛ→≡ : {B : Type i} {F : B → Type j} {u v : Σ F} → u ≡ₛ v → u ≡ v
≡ₛ→≡ (ref b , ref e) = ref (b , e)

≡→≡ₛ : {B : Type i} {F : B → Type j} {u v : Σ F} → u ≡ v → u ≡ₛ v
≡→≡ₛ (ref (b , e)) = ref b , ref e

{- Simple Types -}

data 𝟘 : Type where

𝟘-elim : (F : 𝟘 → Type i) (x : 𝟘) → F x
𝟘-elim _ ()

𝟘-elim' : (B : Type i) → 𝟘 → B
𝟘-elim' _ ()

data 𝟙 : Type where
  ⋆ : 𝟙

data 𝟚 : Type where
  𝟎 𝟏 : 𝟚

{-# BUILTIN BOOL  𝟚 #-}
{-# BUILTIN TRUE  𝟏 #-}
{-# BUILTIN FALSE 𝟎 #-}

-- We have a notion of negation:

¬ : Type i → Type i
¬ A = A → 𝟘

data ℕ : Type where
  nil : ℕ
  suc : ℕ → ℕ

{-# BUILTIN NATURAL ℕ #-}

data _+_ (L : Type i) (R : Type j) : Type (lmax i j) where
  il : L → (L + R)
  ir : R → (L + R)

_×_ : Type i → Type j → Type (lmax i j)
L × R = Σ \(_ : L) → R

_↔_ : Type i → Type j → Type (lmax i j)
L ↔ R = (L → R) × (R → L)

-- Path Laws

!-invo : {A : Type i} {x y : A} (p : x ≡ y) → ! (! p) ≡ p
!-invo (ref a) = ref (ref a)

!-linv : {A : Type i} {x y : A} (p : x ≡ y) → ! p ∙ p ≡ ref y
!-linv (ref a) = ref (ref a)

!-rinv : {A : Type i} {x y : A} (p : x ≡ y) → p ∙ ! p ≡ ref x
!-rinv (ref a) = ref (ref a)

∙-lunit : {A : Type i} {x y : A} (p : x ≡ y) → ref x ∙ p ≡ p
∙-lunit (ref a) = ref (ref a)

∙-runit : {A : Type i} {x y : A} (p : x ≡ y) → p ∙ ref y ≡ p
∙-runit (ref a) = ref (ref a)

∙-assoc : {A : Type i} {x y z w : A} (p : x ≡ y) (q : y ≡ z) (r : z ≡ w) → p ∙ (q ∙ r) ≡ (p ∙ q) ∙ r
∙-assoc (ref a) (ref a) (ref a) = ref (ref a)

∙-rcancel : {A : Type i} {x y z : A} {p q : x ≡ y} (r : y ≡ z) → p ∙ r ≡ q ∙ r → p ≡ q
∙-rcancel {p = p} {q = q} (ref y) h = ! (∙-runit p) ∙ h ∙ (∙-runit q)

ap-▹ : {A : Type i} {B : Type j} {C : Type k} (f : A → B) (g : B → C) {x y : A} (p : x ≡ y) → ap (f ▹ g) p ≡ ap g (ap f p)
ap-▹ f g (ref a) = ref (ref (g (f a)))

ap-id : {S : Type i} {T : Type j} {x y : S} (p : x ≡ y) → ap id p ≡ p
ap-id (ref x) = ref (ref x)

{- Equivalences -}

nat-htpy : {S : Type i} {T : Type j} {f g : S → T} (H : f ∼ g) {x y : S} (p : x ≡ y) → ap f p ∙ H y ≡ H x ∙ ap g p
nat-htpy H (ref x) = ∙-lunit _ ∙ ! (∙-runit _)

inj : {A : Type i} {B : Type j} → (A → B) → Type (lmax i j)
inj {_} {_} {A} {B} f = {x y : A} → f x ≡ f y → x ≡ y

retr : {A : Type i} {B : Type j} → (A → B) → Type (lmax i j)
retr {_} {_} {A} {B} f = Σ \(g : B → A) → (f ▹ g) ∼ id

sect : {A : Type i} {B : Type j} → (A → B) → Type (lmax i j)
sect {_} {_} {A} {B} f = Σ \(g : B → A) → (g ▹ f) ∼ id

is-equiv : {A : Type i} {B : Type j} → (A → B) → Type (lmax i j)
is-equiv f = (sect f) × (retr f)

_≃_ : (A : Type i) (B : Type j) → Type (lmax i j)
A ≃ B = Σ \(f : A → B) → is-equiv f

fib : {T : Type i} {B : Type j} (p : T → B) (b : B) → Type (lmax i j)
fib p b = Σ \t → p t ≡ b

is-contr : Type i → Type i
is-contr A = Σ \(a : A) → (b : A) → a ≡ b

is-hae : {S : Type i} {T : Type j} (f : S → T) → Type (lmax i j)
is-hae f = Σ \g → Σ \((gs , gr) : ((g ▹ f ∼ id) × (f ▹ g ∼ id))) → (f ▹∼ gs) ∼ (gr ∼▹ f)

is-qinv : {S : Type i} {T : Type j} (f : S → T) → Type (lmax i j)
is-qinv f = Σ \f⁻¹ → ((f⁻¹ ▹ f ∼ id) × (f ▹ f⁻¹ ∼ id))

equiv→qinv : {S : Type i} {T : Type j} {f : S → T} → is-equiv f → is-qinv f
equiv→qinv {f = f} ((s , ps) , (r , pr)) = s , (ps , (((f ▹ s) ▹∼ !∼ pr) ∙∼ (f ▹∼ ps ∼▹ r) ∙∼ pr))

qinv→equiv : {S : Type i} {T : Type j} {f : S → T} → is-qinv f → is-equiv f
qinv→equiv {f = f} (g , ps , pr) = (g , ps) , (g , pr)

qinv→hae : {S : Type i} {T : Type j} {f : S → T} → is-qinv f → is-hae f
πb (qinv→hae (g , _)) = g
πb (πf (qinv→hae {f = f} (g , ps , pr))) = (\x → ! (ps (f (g x))) ∙ ap f (pr (g x)) ∙ ps x) , pr
πf (πf (qinv→hae {T = T} {f = f} (g , ps , pr))) = \x →
  ap (\z → ! (ps (f (g (f x)))) ∙
  ap f z ∙ ps (f x)) (! (∙-rcancel (pr x) (nat-htpy pr (pr x) ∙ ap (\y → pr (g (f x)) ∙ y) (ap-id {T = T} (pr x))))) ∙
  ap (\z → ! (ps (f (g (f x)))) ∙ z ∙ ps (f x)) (! (ap-▹ (f ▹ g) f (pr x))) ∙
  ap (\z → ! (ps (f (g (f x)))) ∙ z) (nat-htpy (f ▹∼ ps) (pr x)) ∙
  ∙-assoc _ _ _ ∙
  ap (\z → z ∙ ap f (pr x)) (!-linv _) ∙
  ∙-lunit _

hae→contr : {S : Type i} {T : Type j} {f : S → T} → is-hae f → Π ((fib f) ▹ is-contr)
hae→contr {f = f} (g , ((gs , gr) , c)) t =
  (g t , gs t) ,
  \{(s , ref .(f s)) → ≡ₛ→≡ (gr s , (obs f (gr s) (gs (f s))) ∙
                                    ap (\x → ! x ∙ gs (f s)) (! (c s)) ∙
                                    !-linv (gs (f s)))} where
  obs : {S : Type i} {T : Type j} (f : S → T) {x x' : S} (p : x ≡ x') {t : T} (q : f x ≡ t)
      → tr (\s → f s ≡ t) p q ≡ ! (ap f p) ∙ q
  obs f (ref s) q = ! (∙-lunit _)

!≃ : {S : Type i} {T : Type j} → S ≃ T → T ≃ S
!≃ (S→T , eq) with equiv→qinv eq
... | T→S , ps , pr = T→S , qinv→equiv (S→T , pr , ps)

_∙≃_ : {A : Type i} {B : Type j} {C : Type k} → A ≃ B → B ≃ C → A ≃ C
_∙≃_ (A→B , eqAB) (B→C , eqBC) with equiv→qinv eqAB | equiv→qinv eqBC
... | B→A , abs , abr | C→B , bcs , bcr =
  A→B ▹ B→C ,
  qinv→equiv (C→B ▹ B→A , (C→B ▹∼ abs ∼▹ B→C) ∙∼ bcs , (A→B ▹∼ bcr ∼▹ B→A) ∙∼ abr)
infixr 7 _∙≃_
