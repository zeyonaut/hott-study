{-# OPTIONS --without-K --exact-split --safe #-}

module SS2022.Prelude where

open import Agda.Primitive using (Level; lsuc) renaming (Set to Type; lzero to lnil; _âŠ”_ to lmax) public

private variable i j k : Level

{- Path Types -}

-- For each type, its family of homogeneous path types is generated by constant loops at each point (reflexivity).

data _â‰¡_ {A : Type i} : A â†’ A â†’ Type i where
  ref : (x : A) â†’ x â‰¡ x
infix 0 _â‰¡_

{-# BUILTIN EQUALITY _â‰¡_  #-}

! : {A : Type i} {x y : A} â†’ x â‰¡ y â†’ y â‰¡ x
! (ref _) = ref _

_âˆ™_ : {A : Type i} {x y z : A} â†’ x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
ref _ âˆ™ ref _ = ref _
infixr 7 _âˆ™_

-- We can hence create a dependent path type as follows:

data Id {B : Type i} (F : B â†’ Type j) : {bâ‚€ bâ‚ : B} (p : bâ‚€ â‰¡ bâ‚) (eâ‚€ : F bâ‚€) (eâ‚ : F bâ‚) â†’ Type (lmax i j) where
  rfd : {b : B} (e : F b) â†’ Id F (ref b) e e
  
{- Pi Types -}

-- Pi types are built into Agda, but the following provides a convenient way to specify the Pi type of a fibration.

Î  : {B : Type i} (F : B â†’ Type j) â†’ Type (lmax i j)
Î  F = âˆ€ b â†’ F b

-- Identity function.

id : {A : Type i} â†’ A â†’ A
id a = a

-- Composition

_â–¹_ : {A : Type i} {B : Type j} {F : B â†’ Type k} â†’ (f : A â†’ B) â†’ (Î  F) â†’ (a : A) â†’ F (f a)
(f â–¹ g) a = g (f a)
infixr 7 _â–¹_

-- We can transport points between fibers given a path between their base points.

tr : {B : Type i} (F : B â†’ Type j) â†’ {b b' : B} â†’ b â‰¡ b' â†’ F b â†’ F b'
tr F (ref b) e = e

-- It is convenient to work with pathwise equality of functions:

_âˆ¼_ : {B : Type i} {F : B â†’ Type j} (f g : Î  F) â†’ Type (lmax i j)
_âˆ¼_ {_} {_} {B} {F} f g = {x y : B} â†’ (p : x â‰¡ y) â†’ tr F p (f x) â‰¡ g y
infix 0 _âˆ¼_

_âˆ¼'_ : {A : Type i} {B : Type j} (f g : A â†’ B) â†’ Type (lmax i j)
_âˆ¼'_ f g = âˆ€ {x y} â†’ x â‰¡ y â†’ f x â‰¡ g y
infix 0 _âˆ¼'_

-- We can apply functions to paths by applying them to their endpoints.

ap : {A : Type i} {B : Type j} (f : A â†’ B) â†’ f âˆ¼' f
ap f (ref a) = ref (f a)

apd : {A : Type i} {B : Type j} (f : A â†’ B) â†’ f âˆ¼ f
apd f (ref a) = ref (f a)

-- We can apply an n-ary function to n paths to get a single path.

apâ‚‚ : {A : Type i} {B : Type j} {C : Type k} (f : A â†’ B â†’ C) {a a' : A} {b b' : B} â†’ a â‰¡ a' â†’ b â‰¡ b' â†’ f a b â‰¡ f a' b'
apâ‚‚ f (ref a) (ref b) = ref (f a b)

-- Note: apâ‚€ would be ref and apâ‚ would be ap.

{- Sigma Types -}

-- An indexed sum consists of a base B and a fibration E.
-- We use a record only to get the eta-reduction rule.
record Î£ {B : Type i} (F : B â†’ Type j) : Type (lmax i j) where
  constructor
    _,_
  field
    -- From any pair, we can project out a base point and a fiber point.
    Ï€b : B
    Ï€f : F Ï€b
open Î£ public
infixr 0 _,_

-- {-# BUILTIN SIGMA Î£ #-}

{- Simple Types -}

data ğŸ˜ : Type where

ğŸ˜-elim : {F : ğŸ˜ â†’ Type i} (x : ğŸ˜) â†’ F x
ğŸ˜-elim ()

ğŸ˜-elim' : {B : Type i} â†’ ğŸ˜ â†’ B
ğŸ˜-elim' ()

data ğŸ™ : Type where
  â‹† : ğŸ™

data ğŸš : Type where
  ğŸ ğŸ : ğŸš

{-# BUILTIN BOOL  ğŸš #-}
{-# BUILTIN TRUE  ğŸ #-}
{-# BUILTIN FALSE ğŸ #-}

-- We have a notion of negation:

Â¬ : Type i â†’ Type i
Â¬ A = A â†’ ğŸ˜

data â„• : Type where
  nil : â„•
  suc : â„• â†’ â„•

{-# BUILTIN NATURAL â„• #-}

data _+_ (A : Type i) (B : Type j) : Type (lmax i j) where
  il : A â†’ (A + B)
  ir : B â†’ (A + B)

_Ã—_ : Type i â†’ Type j â†’ Type (lmax i j)
L Ã— R = Î£ \(_ : L) â†’ R

_â†”_ : Type i â†’ Type j â†’ Type (lmax i j)
L â†” R = (L â†’ R) Ã— (R â†’ L)
