{-# OPTIONS --without-K --exact-split --safe #-}

module SS2022.Prelude where

open import Agda.Primitive using (Level; lsuc) renaming (Set to Type; lzero to lnil; _âŠ”_ to lmax) public

private variable i j k â„“ : Level

{- Path Types -}

-- For each type, its family of homogeneous path types is generated by constant loops at each point (reflexivity).

data _â‰¡_ {A : Type i} : A â†’ A â†’ Type i where
  ref : (x : A) â†’ x â‰¡ x
infix 0 _â‰¡_

{-# BUILTIN EQUALITY _â‰¡_  #-}

! : {A : Type i} {x y : A} â†’ x â‰¡ y â†’ y â‰¡ x
! (ref _) = ref _

_âˆ™_ : {A : Type i} {x y z : A} â†’ x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z
ref _ âˆ™ ref _ = ref _
infixr 7 _âˆ™_

-- We can hence create a dependent path type as follows:

data Id {B : Type i} (F : B â†’ Type j) : {bâ‚€ bâ‚ : B} (p : bâ‚€ â‰¡ bâ‚) (eâ‚€ : F bâ‚€) (eâ‚ : F bâ‚) â†’ Type (lmax i j) where
  rfd : {b : B} (e : F b) â†’ Id F (ref b) e e
  
{- Pi Types -}

-- Pi types are built into Agda, but the following provides a convenient way to specify the Pi type of a fibration.

Î  : {B : Type i} (F : B â†’ Type j) â†’ Type (lmax i j)
Î  F = âˆ€ b â†’ F b

-- Identity function.

id : {T : Type i} â†’ T â†’ T
id a = a

-- Composition

_â–¹_ : {A : Type i} {B : Type j} {F : B â†’ Type k} â†’ (f : A â†’ B) â†’ (Î  F) â†’ (a : A) â†’ F (f a)
(f â–¹ g) a = g (f a)
infixr 7 _â–¹_

-- We can transport points between fibers given a path between their base points.

tr : {B : Type i} (F : B â†’ Type j) â†’ {b b' : B} â†’ b â‰¡ b' â†’ F b â†’ F b'
tr F (ref b) e = e

-- Pointwise and pathwise equalities of functions:

_âˆ¼_ : {B : Type i} {F : B â†’ Type j} (f g : Î  F) â†’ Type (lmax i j)
_âˆ¼_ f g = âˆ€ x â†’ f x â‰¡ g x
infix 0 _âˆ¼_

_â‰¡â‚š_ : {B : Type i} {F : B â†’ Type j} (f g : Î  F) â†’ Type (lmax i j)
_â‰¡â‚š_ {F = F} f g = âˆ€ {x y} â†’ (p : x â‰¡ y) â†’ tr F p (f x) â‰¡ g y
infix 0 _â‰¡â‚š_

_â‰¡â‚˜_ : {D : Type i} {C : Type j} (f g : D â†’ C) â†’ Type (lmax i j)
_â‰¡â‚˜_ f g = âˆ€ {x y} â†’ x â‰¡ y â†’ f x â‰¡ g y
infix 0 _â‰¡â‚˜_

-- We can apply functions to paths by applying them to their endpoints.

ap : {A : Type i} {B : Type j} (f : A â†’ B) â†’ f â‰¡â‚˜ f
ap f (ref a) = ref (f a)

apd : {A : Type i} {B : Type j} (f : A â†’ B) â†’ f â‰¡â‚š f
apd f (ref a) = ref (f a)

-- We can apply an n-ary function to n paths to get a single path.

apâ‚‚ : {A : Type i} {B : Type j} {C : Type k} (f : A â†’ B â†’ C) {a a' : A} {b b' : B} â†’ a â‰¡ a' â†’ b â‰¡ b' â†’ f a b â‰¡ f a' b'
apâ‚‚ f (ref a) (ref b) = ref (f a b)

-- Note: apâ‚€ would be ref and apâ‚ would be ap.

_âˆ¼â–¹_ : {A : Type i} {B : Type j} {C : Type k} {f g : A â†’ B} â†’ f âˆ¼ g â†’ (h : B â†’ C) â†’ (f â–¹ h) âˆ¼ (g â–¹ h)
(p âˆ¼â–¹ h) x = ap h (p x)
infix 7 _âˆ¼â–¹_

_â–¹âˆ¼_ : {A : Type i} {B : Type j} {C : Type k} {f g : B â†’ C} (h : A â†’ B) â†’  f âˆ¼ g â†’ (h â–¹ f) âˆ¼ (h â–¹ g)
(h â–¹âˆ¼ p) x = p (h x)
infix 7 _â–¹âˆ¼_

_â–¹âˆ¼_âˆ¼â–¹_ : {A : Type i} {B : Type j} {C : Type k} {D : Type â„“} {f g : B â†’ C} (h : A â†’ B) â†’ f âˆ¼ g â†’ (h' : C â†’ D) â†’ (h â–¹ f â–¹ h') âˆ¼ (h â–¹ g â–¹ h')
h â–¹âˆ¼ p âˆ¼â–¹ h' = h â–¹âˆ¼ (p âˆ¼â–¹ h')
infix 7 _â–¹âˆ¼_âˆ¼â–¹_

!âˆ¼ : {B : Type i} {F : B â†’ Type j} {f g : Î  F} â†’ f âˆ¼ g â†’ g âˆ¼ f
!âˆ¼ p x = ! (p x)

_âˆ™âˆ¼_ : {B : Type i} {F : B â†’ Type j} {f g h : Î  F} â†’ f âˆ¼ g â†’ g âˆ¼ h â†’ f âˆ¼ h
(p âˆ™âˆ¼ q) x = p x âˆ™ q x
infixr 7 _âˆ™âˆ¼_


{- Sigma Types -}

-- An indexed sum consists of a base B and a fibration E.
-- We use a record only to get the eta-reduction rule.
record Î£ {B : Type i} (F : B â†’ Type j) : Type (lmax i j) where
  constructor
    _,_
  field
    -- From any pair, we can project out a base point and a fiber point.
    Ï€b : B
    Ï€f : F Ï€b
open Î£ public
infixr 0 _,_

-- {-# BUILTIN SIGMA Î£ #-}

-- Observational equality of sigma types:

_â‰¡â‚›_ : {B : Type i} {F : B â†’ Type j} (u v : Î£ F) â†’ Type (lmax i j)
_â‰¡â‚›_ {F = F} (b , e) (b' , e') = Î£ \(p : b â‰¡ b') â†’ tr F p e â‰¡ e'
infix 0 _â‰¡â‚›_

â‰¡â‚›â†’â‰¡ : {B : Type i} {F : B â†’ Type j} {u v : Î£ F} â†’ u â‰¡â‚› v â†’ u â‰¡ v
â‰¡â‚›â†’â‰¡ (ref b , ref e) = ref (b , e)

â‰¡â†’â‰¡â‚› : {B : Type i} {F : B â†’ Type j} {u v : Î£ F} â†’ u â‰¡ v â†’ u â‰¡â‚› v
â‰¡â†’â‰¡â‚› (ref (b , e)) = ref b , ref e

{- Simple Types -}

data ğŸ˜ : Type where

ğŸ˜-elim : (F : ğŸ˜ â†’ Type i) (x : ğŸ˜) â†’ F x
ğŸ˜-elim _ ()

ğŸ˜-elim' : (B : Type i) â†’ ğŸ˜ â†’ B
ğŸ˜-elim' _ ()

data ğŸ™ : Type where
  â‹† : ğŸ™

data ğŸš : Type where
  ğŸ ğŸ : ğŸš

{-# BUILTIN BOOL  ğŸš #-}
{-# BUILTIN TRUE  ğŸ #-}
{-# BUILTIN FALSE ğŸ #-}

-- We have a notion of negation:

Â¬ : Type i â†’ Type i
Â¬ A = A â†’ ğŸ˜

data â„• : Type where
  nil : â„•
  suc : â„• â†’ â„•

{-# BUILTIN NATURAL â„• #-}

data _+_ (L : Type i) (R : Type j) : Type (lmax i j) where
  il : L â†’ (L + R)
  ir : R â†’ (L + R)

_Ã—_ : Type i â†’ Type j â†’ Type (lmax i j)
L Ã— R = Î£ \(_ : L) â†’ R

_â†”_ : Type i â†’ Type j â†’ Type (lmax i j)
L â†” R = (L â†’ R) Ã— (R â†’ L)

-- Path Laws

!-invo : {A : Type i} {x y : A} (p : x â‰¡ y) â†’ ! (! p) â‰¡ p
!-invo (ref a) = ref (ref a)

!-linv : {A : Type i} {x y : A} (p : x â‰¡ y) â†’ ! p âˆ™ p â‰¡ ref y
!-linv (ref a) = ref (ref a)

!-rinv : {A : Type i} {x y : A} (p : x â‰¡ y) â†’ p âˆ™ ! p â‰¡ ref x
!-rinv (ref a) = ref (ref a)

âˆ™-lunit : {A : Type i} {x y : A} (p : x â‰¡ y) â†’ ref x âˆ™ p â‰¡ p
âˆ™-lunit (ref a) = ref (ref a)

âˆ™-runit : {A : Type i} {x y : A} (p : x â‰¡ y) â†’ p âˆ™ ref y â‰¡ p
âˆ™-runit (ref a) = ref (ref a)

âˆ™-assoc : {A : Type i} {x y z w : A} (p : x â‰¡ y) (q : y â‰¡ z) (r : z â‰¡ w) â†’ p âˆ™ (q âˆ™ r) â‰¡ (p âˆ™ q) âˆ™ r
âˆ™-assoc (ref a) (ref a) (ref a) = ref (ref a)

âˆ™-rcancel : {A : Type i} {x y z : A} {p q : x â‰¡ y} (r : y â‰¡ z) â†’ p âˆ™ r â‰¡ q âˆ™ r â†’ p â‰¡ q
âˆ™-rcancel {p = p} {q = q} (ref y) h = ! (âˆ™-runit p) âˆ™ h âˆ™ (âˆ™-runit q)

ap-â–¹ : {A : Type i} {B : Type j} {C : Type k} (f : A â†’ B) (g : B â†’ C) {x y : A} (p : x â‰¡ y) â†’ ap (f â–¹ g) p â‰¡ ap g (ap f p)
ap-â–¹ f g (ref a) = ref (ref (g (f a)))

ap-id : {S : Type i} {T : Type j} {x y : S} (p : x â‰¡ y) â†’ ap id p â‰¡ p
ap-id (ref x) = ref (ref x)

{- Equivalences -}

nat-htpy : {S : Type i} {T : Type j} {f g : S â†’ T} (H : f âˆ¼ g) {x y : S} (p : x â‰¡ y) â†’ ap f p âˆ™ H y â‰¡ H x âˆ™ ap g p
nat-htpy H (ref x) = âˆ™-lunit _ âˆ™ ! (âˆ™-runit _)

inj : {A : Type i} {B : Type j} â†’ (A â†’ B) â†’ Type (lmax i j)
inj {_} {_} {A} {B} f = {x y : A} â†’ f x â‰¡ f y â†’ x â‰¡ y

retr : {A : Type i} {B : Type j} â†’ (A â†’ B) â†’ Type (lmax i j)
retr {_} {_} {A} {B} f = Î£ \(g : B â†’ A) â†’ (f â–¹ g) âˆ¼ id

sect : {A : Type i} {B : Type j} â†’ (A â†’ B) â†’ Type (lmax i j)
sect {_} {_} {A} {B} f = Î£ \(g : B â†’ A) â†’ (g â–¹ f) âˆ¼ id

is-equiv : {A : Type i} {B : Type j} â†’ (A â†’ B) â†’ Type (lmax i j)
is-equiv f = (sect f) Ã— (retr f)

_â‰ƒ_ : (A : Type i) (B : Type j) â†’ Type (lmax i j)
A â‰ƒ B = Î£ \(f : A â†’ B) â†’ is-equiv f

fib : {T : Type i} {B : Type j} (p : T â†’ B) (b : B) â†’ Type (lmax i j)
fib p b = Î£ \t â†’ p t â‰¡ b

is-contr : Type i â†’ Type i
is-contr A = Î£ \(a : A) â†’ (b : A) â†’ a â‰¡ b

is-hae : {S : Type i} {T : Type j} (f : S â†’ T) â†’ Type (lmax i j)
is-hae f = Î£ \g â†’ Î£ \((gs , gr) : ((g â–¹ f âˆ¼ id) Ã— (f â–¹ g âˆ¼ id))) â†’ (f â–¹âˆ¼ gs) âˆ¼ (gr âˆ¼â–¹ f)

is-qinv : {S : Type i} {T : Type j} (f : S â†’ T) â†’ Type (lmax i j)
is-qinv f = Î£ \fâ»Â¹ â†’ ((fâ»Â¹ â–¹ f âˆ¼ id) Ã— (f â–¹ fâ»Â¹ âˆ¼ id))

equivâ†’qinv : {S : Type i} {T : Type j} {f : S â†’ T} â†’ is-equiv f â†’ is-qinv f
equivâ†’qinv {f = f} ((s , ps) , (r , pr)) = s , (ps , (((f â–¹ s) â–¹âˆ¼ !âˆ¼ pr) âˆ™âˆ¼ (f â–¹âˆ¼ ps âˆ¼â–¹ r) âˆ™âˆ¼ pr))

qinvâ†’equiv : {S : Type i} {T : Type j} {f : S â†’ T} â†’ is-qinv f â†’ is-equiv f
qinvâ†’equiv {f = f} (g , ps , pr) = (g , ps) , (g , pr)

qinvâ†’hae : {S : Type i} {T : Type j} {f : S â†’ T} â†’ is-qinv f â†’ is-hae f
Ï€b (qinvâ†’hae (g , _)) = g
Ï€b (Ï€f (qinvâ†’hae {f = f} (g , ps , pr))) = (\x â†’ ! (ps (f (g x))) âˆ™ ap f (pr (g x)) âˆ™ ps x) , pr
Ï€f (Ï€f (qinvâ†’hae {T = T} {f = f} (g , ps , pr))) = \x â†’
  ap (\z â†’ ! (ps (f (g (f x)))) âˆ™
  ap f z âˆ™ ps (f x)) (! (âˆ™-rcancel (pr x) (nat-htpy pr (pr x) âˆ™ ap (\y â†’ pr (g (f x)) âˆ™ y) (ap-id {T = T} (pr x))))) âˆ™
  ap (\z â†’ ! (ps (f (g (f x)))) âˆ™ z âˆ™ ps (f x)) (! (ap-â–¹ (f â–¹ g) f (pr x))) âˆ™
  ap (\z â†’ ! (ps (f (g (f x)))) âˆ™ z) (nat-htpy (f â–¹âˆ¼ ps) (pr x)) âˆ™
  âˆ™-assoc _ _ _ âˆ™
  ap (\z â†’ z âˆ™ ap f (pr x)) (!-linv _) âˆ™
  âˆ™-lunit _

haeâ†’contr : {S : Type i} {T : Type j} {f : S â†’ T} â†’ is-hae f â†’ Î  ((fib f) â–¹ is-contr)
haeâ†’contr {f = f} (g , ((gs , gr) , c)) t =
  (g t , gs t) ,
  \{(s , ref .(f s)) â†’ â‰¡â‚›â†’â‰¡ (gr s , (obs f (gr s) (gs (f s))) âˆ™
                                    ap (\x â†’ ! x âˆ™ gs (f s)) (! (c s)) âˆ™
                                    !-linv (gs (f s)))} where
  obs : {S : Type i} {T : Type j} (f : S â†’ T) {x x' : S} (p : x â‰¡ x') {t : T} (q : f x â‰¡ t)
      â†’ tr (\s â†’ f s â‰¡ t) p q â‰¡ ! (ap f p) âˆ™ q
  obs f (ref s) q = ! (âˆ™-lunit _)

!â‰ƒ : {S : Type i} {T : Type j} â†’ S â‰ƒ T â†’ T â‰ƒ S
!â‰ƒ (Sâ†’T , eq) with equivâ†’qinv eq
... | Tâ†’S , ps , pr = Tâ†’S , qinvâ†’equiv (Sâ†’T , pr , ps)

_âˆ™â‰ƒ_ : {A : Type i} {B : Type j} {C : Type k} â†’ A â‰ƒ B â†’ B â‰ƒ C â†’ A â‰ƒ C
_âˆ™â‰ƒ_ (Aâ†’B , eqAB) (Bâ†’C , eqBC) with equivâ†’qinv eqAB | equivâ†’qinv eqBC
... | Bâ†’A , abs , abr | Câ†’B , bcs , bcr =
  Aâ†’B â–¹ Bâ†’C ,
  qinvâ†’equiv (Câ†’B â–¹ Bâ†’A , (Câ†’B â–¹âˆ¼ abs âˆ¼â–¹ Bâ†’C) âˆ™âˆ¼ bcs , (Aâ†’B â–¹âˆ¼ bcr âˆ¼â–¹ Bâ†’A) âˆ™âˆ¼ abr)
infixr 7 _âˆ™â‰ƒ_
